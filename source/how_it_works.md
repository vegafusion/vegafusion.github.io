# How VegaFusion works
VegaFusion currently has two components: The Planner and the Runtime.

## Planner
The Planner starts with an arbitrary Vega specification (typically generated by Vega-Lite, but this is not a requirement). The Planner's job is to partition the specification into two valid Vega specifications, one that will execute in the browser with Vega.js, and one that will execute on the server with the VegaFusion Runtime.

VegaFusion does not (yet) provide full coverage of all of Vega's transforms and all of the features of the Vega expression language.  The planner uses information about which transforms and expression functions are supported to make decisions about which parts of the original vega specification can be included in the resulting server specification.  The advantage of this approach is that VegaFusion can accept any Vega specification, and as more support is added over time, more of the input specification will be eligible for inclusion in the server specification.

Along with the client and server specifications, the planner also creates a communication plan.  The communication plan is a specification of the datasets and signals that must be passed from server to client, and from client to server in order for the interactive behavior of the original specification to be preserved.

After planning, the client specification is evaluated by the Vega JavaScript library while the server specification is evaluated by the VegaFusion Runtime.

## Runtime
After planning, the server specification is compiled into a VegaFusion specific task graph specification.  The job of the runtime is to calculate the value of requested nodes within a task graph specification.

A task graph specification includes the values of the root nodes (those with no parents), but it does not include the values of any of the interior nodes (those with parents).  Each node in the task graph is a pure function of the values of its parents.  This enables the Runtime to calculate the value of any node in the Task graph from the specification.  The Runtime uses fingerprinting and caching to avoid repeated calculations of the same nodes.

## Inspecting the planner solution
To inspect how the planner partitioned the Vega specification, wrap the chart in a `VegaFusionWidget` and display it.

```python
import altair as alt
from vega_datasets import data

source = data.seattle_weather()
brush = alt.selection(type='interval', encodings=['x'])

bars = alt.Chart().mark_bar().encode(
    x='month(date):O',
    y='mean(precipitation):Q',
    opacity=alt.condition(brush, alt.OpacityValue(1), alt.OpacityValue(0.7)),
).add_selection(
    brush
)

line = alt.Chart().mark_rule(color='firebrick').encode(
    y='mean(precipitation):Q',
    size=alt.SizeValue(3)
).transform_filter(
    brush
)

widget = vf.VegaFusionWidget(alt.layer(bars, line, data=source))
widget
```
<video width="600" controls>
  <source src="https://user-images.githubusercontent.com/15064365/148408648-43a5cfd0-b0d8-456e-a77a-dd344d8d07df.mov" type="video/mp4">
This browser does not support the video tag.
</video>

Then print out the value of the following widget properties:

 - `widget.spec`: This is the Vega-Lite specification created by Altair
 - `widget.full_vega_spec`: This is the Vega specification produced by Vega-Lite
 - `widget.server_vega_spec`: This is the portion of the full Vega spec that was planned to run on the server (The Python kernel in case)
 - `widget.client_vega_spec`: This is the portion of the full Vega spec that was planned to run on the client, being rendered by Vega.js
 - `widget.comm_plan`: This is the specification of which signals and datasets must be transfered between the client and server in order to preserve the interactive behavior of the original specification.
